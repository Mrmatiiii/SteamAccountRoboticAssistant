// jsSha 1.6 - important version!
// misc conversion-functions
function hexToBytes(n) {
  for (var t = [], r = 0; r < n.length; r += 2) t.push(parseInt(n.substr(r, 2), 16));
  return t
}
function dec2hex(n) {
  return (15.5 > n ? "0" : "") + Math.round(n).toString(16)
}
function leftpad(n, t, r) {
  return t + 1 >= n.length && (n = Array(t + 1 - n.length).join(r) + n), n
}
function base64ToHex(n) {
  for (var t = 0, r = atob(n.replace(/[ \r\n]+$/, "")), e = []; t < r.length; ++t) {
    var o = r.charCodeAt(t).toString(16);
    1 === o.length && (o = "0" + o), e[e.length] = o
  }
  return e.join(" ")
}
function strToHex(str) {
	var hex = '';
	for(var i=0;i<str.length;i++) {
		hex += ''+str.charCodeAt(i).toString(16);
	}
	return hex;
}

// main functions
function generateAuthCode(secret, timeOffset) {
	var secret = base64ToHex(secret).replace(/ /g, '');
	var epoch = Math.floor(Date.now() / 1000) + (timeOffset || 0);
	var time = leftpad(dec2hex(Math.floor(epoch / 30)), 16, 0);

	// Let the hashing begin
	var hmacObj = new jsSHA(time, "HEX");
	var hmac = hmacObj.getHMAC(secret, "HEX", "SHA-1", "HEX");

	hmac = hexToBytes(hmac);

	// Pick the last part of the buffer and then pick 4 2-bytes
	var start = hmac[19] & 0x0F;
	hmac = hmac.slice(start, start + 4);

	// Read ArrayBuffer - Magic comes in
	var fullcode = ((hmac[0] * 0x1000000) + (hmac[1] << 16) | (hmac[2] << 8) | hmac[3]) & 0x7fffffff;
	var chars = '23456789BCDFGHJKMNPQRTVWXY';

	var code = '';
	for(var i = 0; i < 5; i++) {
	  code += chars.charAt(fullcode % chars.length);
	  fullcode /= chars.length;
	}

	return(code);
}

function getConfirmationKey(identitySecret, time, tag) {

	// Possible tags are:
	// 'conf', 'details', 'allow', 'cancel'
	var dfd = $.Deferred();
	var dataLen = 8;
	var buffer;

	// Buffersize generated by needed action
	if(tag) {
		if(tag.length > 32) {
			dataLen += 32;
		} else {
			dataLen += tag.length;
		}
	}

	// Put everything together in a hex-string
	buffer = '00000000'+dec2hex(time)+strToHex(tag);

	// Let the hashing begin and return base64 (last parameter of getHmac)
	var hmacObj = new jsSHA(buffer, "HEX");
	var hmac = hmacObj.getHMAC(identitySecret, "B64", "SHA-1", "B64");
	dfd.resolve(hmac);

	return dfd.promise();
};

async function getServerTime(){

	const startTime = Date.now(); 
	const fetchData = await fun.fetchData({
	  	delay: 0,
		options: { 
			method: 'POST',
			credentials: 'include' 
		},
		url: 'https://api.steampowered.com/ITwoFactorService/QueryTime/v1/',
		format: 'json'
	});
	
	const localTime = Date.now(); // also used as "endTime"
	const latency 	= Math.floor(((localTime - startTime) + localTime)/1000);
	const tOffset 	= fetchData.response.server_time - latency;

	return tOffset;

}
/*

SDA generates DeviceID´s (Android-Phone) randomly, so it isn´t possible
to generate the same DeviceID.

function generateDeviceId(steamID){

	var steamidhex = textToHex(steamID);
	console.log("steamID Str: "+steamID+"\nsteamID Hex: "+steamidhex);
	var sha1 = new jsSHA(steamidhex, "HEX");
	console.log(sha1);
	var replace = $(sha1).toString().replace(/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12}).*$/, '$1-$2-$3-$4-$5');

	console.log(replace);
	return "android:" + Crypto.createHash('sha1').update(steamID.toString()).digest('hex')
		.replace(/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12}).*$/, '$1-$2-$3-$4-$5');

}*/
